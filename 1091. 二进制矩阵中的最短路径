/* n x n 的二进制矩阵 grid 中，返回矩阵中最短 畅通路径 的长度。如果不存在这样的路径，返回 -1 。
二进制矩阵中的 畅通路径 是一条从 左上角 单元格（即，(0, 0)）到 右下角 单元格（即，(n - 1, n - 1)）的路径，该路径同时满足下述要求：

路径途经的所有单元格都的值都是 0 。
路径中所有相邻的单元格应当在 8 个方向之一 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。
畅通路径的长度 是该路径途经的单元格总数。

知识点：
1.-DFS是属于每次深入去找，发现不行了再回头继续找的那种方法，适合找东西个数的问题（海岛数量的那题）
  -BFS是属于每次都进行一步，走完一步之后才走下一步，而下一步中涵盖了所有的可能的这种方法，适合找到最短路径/最少次数的问题（如腐烂的橘子）

2.bfs广度优先搜索：用队列的形式，先进先出。
代码思路：
1）来个队列，用来保存
2）将起点入队
3）把气垫标记为阻塞
4）int 层数=1

int n = 10, m = 10;                   //地图宽高
void BFS()
{
    queue que;              //用队列来保存路口
    int graph[n][m];          //地图
    int px[] = {-1, 0, 1, 0};   //移动方向的数组 上下左右
    int py[] = {0, -1, 0, 1};
    que.push(起点入队);      //将起点入队
    while (!que.empty()) {    //只要队列不为空
        auto temp = que.pop();          //得到队列中的元素
        for (int i = 0; i != 4; ++i) {
            if(//可以走) {
                //标记当前格子
                //将当前状态入队列，等待下次提取
            }
        }
    } 
}
